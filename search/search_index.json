{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"server_how_to/","title":"Server how to","text":""},{"location":"server_how_to/#ecs-development-guide","title":"\ud83e\udde9 ECS Development Guide","text":"<p>Our R-Type project uses a custom Entity-Component-System (ECS) architecture. This guide explains how to extend the system with new components, systems, entities, and network packets.</p>"},{"location":"server_how_to/#adding-a-new-component","title":"\ud83d\udd27 Adding a New Component","text":"<p>Components are simple data structures that hold state for entities.</p> <p>1. Create the component header file: <pre><code>// game_engine/ecs/components/NewComponent.hpp\n#pragma once\n\nnamespace ecs {\n  struct NewComponent {\n    // Add your data members here\n    float value = 0.0f;\n    int count = 0;\n    bool isActive = true;\n  };\n}  // namespace ecs\n</code></pre></p> <p>2. Register the component in your initialization code: <pre><code>// server/src/game/Game.cpp\n_ecsManager.registerComponent&lt;ecs::NewComponent&gt;();\n</code></pre></p> <p>3. All methods for components related to a entity: <pre><code>// Add component to entity\nEntity entity = ecsManager.createEntity();\necsManager.addComponent(entity, NewComponent{1.5f, 10, true});\n\n// Get and modify component\nauto&amp; component = ecsManager.getComponent&lt;NewComponent&gt;(entity);\ncomponent.value = 2.0f;\n\n// Check if entity has component\nif (ecsManager.hasComponent&lt;NewComponent&gt;(entity)) {\n  // Do something\n}\n\n// Remove component\necsManager.removeComponent&lt;NewComponent&gt;(entity);\n</code></pre></p>"},{"location":"server_how_to/#adding-a-new-system","title":"\u2699\ufe0f Adding a New System","text":"<p>Systems contain the logic that operates on entities with specific components.</p> <p>1. Create the system header file: <pre><code>// game_engine/ecs/systems/NewSystem.hpp\n#pragma once\n\n#include \"ECSManager.hpp\"\n#include \"System.hpp\"\n\nnamespace ecs {\n  class NewSystem : public System {\n    public:\n      explicit NewSystem(ECSManager&amp; ecsManager = ECSManager::getInstance())\n          : _ecsManager(ecsManager) {}\n\n      void update(float deltaTime) override;\n\n    private:\n      ECSManager&amp; _ecsManager;\n\n      // Add private methods for system logic\n      void processEntity(Entity entity, float deltaTime);\n  };\n}  // namespace ecs\n</code></pre></p> <p>2. Implement the system logic: <pre><code>// game_engine/ecs/systems/NewSystem.cpp\n#include \"NewSystem.hpp\"\n#include \"NewComponent.hpp\"\n#include \"PositionComponent.hpp\" // If you need other components\n\nvoid NewSystem::update(float deltaTime) {\n  for (auto const&amp; entity : _entities) {\n    processEntity(entity, deltaTime);\n  }\n}\n\nvoid NewSystem::processEntity(Entity entity, float deltaTime) {\n  // Get required components\n  auto&amp; newComp = _ecsManager.getComponent&lt;NewComponent&gt;(entity);\n  auto&amp; position = _ecsManager.getComponent&lt;PositionComponent&gt;(entity);\n\n  // Implement your system logic here\n  if (newComp.isActive) {\n    position.x += newComp.value * deltaTime;\n    newComp.count++;\n  }\n}\n</code></pre></p> <p>3. Register and configure the system:</p> <p>3.1. Add members to Game.hpp <pre><code>namespace game {\n\n  class Game {\n    public:\n      Game();\n      ~Game();\n    ...\n    private:\n      std::shared_ptr&lt;ecs::NewSystem&gt; _newSystem;\n  }\n}\n</code></pre></p> <pre><code>// server/src/game/Game.cpp\n\n// Register the system\n_newSystem = _ecsManager.registerSystem&lt;NewSystem&gt;();\n\n\n// Define which components this system requires\nSignature newSignature;\nnewSignature.set(_ecsManager.getComponentType&lt;NewComponent&gt;());\nnewSignature.set(_ecsManager.getComponentType&lt;PositionComponent&gt;());\n_ecsManager.setSystemSignature&lt;NewSystem&gt;(newSignature);\n</code></pre>"},{"location":"server_how_to/#creating-game-entities","title":"\ud83c\udfaf Creating Game Entities","text":"<p>Entities are combinations of components that represent game objects.</p> <p>Example: Creating a Power-up Entity</p> <p>To create a new entity that displays on map you have to add some things to the Game.hpp.</p> <pre><code>namespace game {\n\n  class Game {\n    public:\n      Game();\n      ~Game();\n    ...\n    private:\n      std::shared_ptr&lt;ecs::PowerUpSystem&gt; _powerUpSystem;\n      std::unordered_map&lt;std::uint32_t, std::shared_ptr&lt;PowerUp&gt;&gt; _powerUps;\n      mutable std::mutex _powerUpMutex\n  }\n}\n</code></pre> <pre><code>Entity createPowerUp(float x, float y, PowerUpType type) {\n  std::shared_ptr&lt;PowerUp&gt; powerUp; \n  Entity entity;\n  {\n    std::scoped_lock ecsLock(_ecsMutex);\n    entity = _ecsManager.createEntity();\n    // Add required components\n    _ecsManager.addComponent&lt;ecs::PositionComponent&gt;(entity, ecs::PositionComponent{x, y});\n    _ecsManager.addComponent&lt;ecs::VelocityComponent&gt;(entity, ecs::VelocityComponent{0.0f, -50.0f}); // Moving upward\n    _ecsManager.addComponent&lt;ecs::PowerUpComponent&gt;(entity, PowerUpComponent{type, 100}); // Custom component\n    _ecsManager.addComponent&lt;ecs::ColliderComponent&gt;(entity, ecs::ColliderComponent{20.0f, 20.0f});\n    powerUp = std::make_shared&lt;PowerUp&gt;(type, x, y);\n  }\n  {\n    std::scoped_lock lk(_powerUpMutex);\n    _powerUp[powerUp_id] = powerUp;\n  }\n  return powerUp;\n}\n</code></pre> <p>Example: Creating an Enemy Entity <pre><code>std::shared_ptr&lt;game::Enemy&gt; game::Game::createEnemy(int enemy_id,\n                                                     const EnemyType type) {\n  std::scoped_lock lock(_enemyMutex);\n  auto entity = _ecsManager.createEntity();\n\n  _ecsManager.addComponent&lt;ecs::EnemyComponent&gt;(entity, {enemy_id, type});\n  _ecsManager.addComponent&lt;ecs::PositionComponent&gt;(entity, {800.0f, 50.0f});\n  _ecsManager.addComponent&lt;ecs::HealthComponent&gt;(entity, {100, 100});\n  _ecsManager.addComponent&lt;ecs::VelocityComponent&gt;(entity, {-3.0f, 0.0f});\n  _ecsManager.addComponent&lt;ecs::ShootComponent&gt;(entity,\n                                                {0.0f, 3.0f, true, 0.0f});\n  _ecsManager.addComponent&lt;ecs::ColliderComponent&gt;(entity, {10.f, 10.f});\n  switch (type) {\n    case EnemyType::BASIC_FIGHTER:\n      _ecsManager.addComponent&lt;ecs::ScoreComponent&gt;(entity, {10});\n      break;\n    default:\n      _ecsManager.addComponent&lt;ecs::ScoreComponent&gt;(entity, {10});\n      break;\n  }\n\n  auto enemy = std::make_shared&lt;Enemy&gt;(enemy_id, entity, _ecsManager);\n  _enemies[enemy_id] = enemy;\n  return enemy;\n}\n</code></pre></p>"},{"location":"server_how_to/#adding-network-packets","title":"\ud83d\udce1 Adding Network Packets","text":"<p>Network packets handle communication between client and server.</p> <p>1. Define the packet structure in core/network/Packet.hpp: <pre><code>// Add to PacketType enum\nenum class PacketType : uint8_t {\n  // ... existing types ...\n  NewPacketType = 0x20, // Use next available ID\n};\n\n// Add packet structure\nstruct ALIGNED NewPacketStruct {\n  PacketHeader header;\n  uint32_t playerId;\n  float someValue;\n  uint8_t someFlag;\n  // Keep structures aligned and size-efficient\n};\n</code></pre></p> <p>2. Create the packet handler: <pre><code>// server/src/packets/PacketHandler.hpp\n#pragma once\n\n#include \"APacket.hpp\"\n\nnamespace packet {\n  ...\n  class NewPacketHandler : public APacket {\n    public:\n      int handlePacket(server::Server&amp; server, server::Client&amp; client,\n                      const char* data, std::size_t size) override;\n  };\n}\n</code></pre></p> <pre><code>// server/src/packets/PacketHandler.cpp\n#include \"NewPacketHandler.hpp\"\n#include \"Packet.hpp\"\n#include \"Server.hpp\"\n\nint packet::NewPacketHandler::handlePacket(server::Server&amp; server, server::Client&amp; client, const char* data, std::size_t size) {\n  if (size &lt; sizeof(NewPacketStruct)) {\n    return -1; // Invalid packet size\n  }\n\n  const auto* packet = reinterpret_cast&lt;const NewPacketStruct*&gt;(data);\n\n    // Validate packet data\n  if (packet-&gt;header.type != PacketType::NewPacketType) {\n    return -1;\n  }\n\n  ...\n\n  return 0; // Success\n}\n</code></pre> <p>3. Register the packet handler: <pre><code>// Add to server/src/packets/PacketFactory.hpp\nprivate:\ninline static const std::unordered_map&lt;\n          PacketType, std::function&lt;std::unique_ptr&lt;APacket&gt;()&gt;&gt;\n          _handlers = {...\n                       {PacketType::NewPacket,\n                        []() { return std::make_unique&lt;NewPacketHandler&gt;(); }}};\n</code></pre></p>"},{"location":"server_how_to/#best-practices","title":"\ud83d\udccb Best Practices","text":"<p>Components: - Keep components simple data containers (no logic) - Use descriptive names (e.g., <code>HealthComponent</code>, not <code>HC</code>) - Group related data together - Consider memory layout and alignment</p> <p>Systems: - One responsibility per system - Process entities in batches when possible - Handle edge cases (empty entity sets, missing components) - Consider system update order dependencies</p> <p>Entities: - Use factory functions for complex entities - Document required component combinations - Clean up entities when no longer needed - Use entity IDs for cross-system communication</p> <p>Packets: - Keep packet structures small and efficient - Validate all input data - Use proper alignment for network data - Handle endianness for cross-platform compatibility - Include packet versioning for protocol evolution</p> <p>Performance Tips: - Cache component lookups in tight loops - Use <code>hasComponent()</code> before <code>getComponent()</code> when uncertain - Minimize entity creation/destruction during gameplay - Profile system update performance regularly</p>"},{"location":"server_protocol/","title":"R-TYPE NETWORK PROTOCOL SPECIFICATION","text":"<p>Internet-Draft \u2014 R-Type Project Intended status: Experimental November 2025</p>"},{"location":"server_protocol/#abstract","title":"Abstract","text":"<p>This document specifies the binary UDP-based network protocol used by the R-Type game server and clients. The protocol defines message types, structure, and sequencing rules to support real-time multiplayer synchronization, combat events, room management, and game state management.</p>"},{"location":"server_protocol/#status-of-this-memo","title":"Status of This Memo","text":"<p>This Internet-Draft is submitted for experimental purposes as part of the R-Type open-source project. It does not represent a standard of the IETF. Distribution of this memo is unlimited.</p>"},{"location":"server_protocol/#copyright-notice","title":"Copyright Notice","text":"<p>Copyright \u00a9 2025 R-Type Project Authors. All rights reserved.</p>"},{"location":"server_protocol/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction </li> <li>Terminology and Conventions </li> <li>Protocol Overview </li> <li>Message Header </li> <li>Message Types </li> <li>Common Messages </li> <li>Client-to-Server Messages </li> <li>Server-to-Client Messages </li> <li>Room Management Messages </li> <li>Acknowledgment Messages </li> <li>Data Types </li> <li>Enumeration Types </li> <li>Message Semantics </li> <li>Example Exchange </li> <li>Security Considerations </li> <li>Future Work Appendix A. Packet Layouts Author's Address  </li> </ol>"},{"location":"server_protocol/#1-introduction","title":"1. Introduction","text":"<p>The R-Type Network Protocol (RTNP) defines how clients and the game server exchange structured binary messages over UDP. It supports synchronization of player state, enemies, projectiles, combat events, room management, and matchmaking in a real-time environment.</p> <p>The protocol is designed for fast-paced multiplayer gameplay, using UDP for minimal latency. Each message is self-contained and includes its own header specifying type and size.</p>"},{"location":"server_protocol/#2-terminology-and-conventions","title":"2. Terminology and Conventions","text":"<p>The key words MUST, MUST NOT, REQUIRED, SHOULD, and MAY in this document are to be interpreted as described in RFC 2119.</p>"},{"location":"server_protocol/#3-protocol-overview","title":"3. Protocol Overview","text":"<p>Clients communicate with the game server using UDP datagrams. Each datagram contains exactly one packet consisting of a PacketHeader followed by a payload specific to the message type.</p> <p>Since UDP is unreliable, clients and servers MUST implement their own sequencing and resynchronization mechanisms using the <code>sequence_number</code> field provided in several packet types. The protocol supports selective acknowledgment through ACK packets.</p> <p>Typical communication flow:</p> <ol> <li>The client sends a <code>PlayerInfo</code> packet to identify itself.</li> <li>The client requests to create or join a room via <code>CreateRoom</code>, <code>JoinRoom</code>, or <code>MatchmakingRequest</code>.</li> <li>The server responds with appropriate room response packets.</li> <li>The server sends a <code>NewPlayer</code> packet for each player in the room.</li> <li>Both sides exchange movement, projectile, and event packets continuously during gameplay.</li> <li>A <code>Heartbeat</code> packet is exchanged periodically to maintain connection state.</li> <li>Critical packets are acknowledged using <code>Ack</code> packets.</li> </ol>"},{"location":"server_protocol/#4-message-header","title":"4. Message Header","text":"<p>All messages start with the following common header: <pre><code>0 1 2 3 4 5 6 7 8\n+-----------------------------------------------------------+\n| Type (1 byte) | Size (4 bytes)                            |\n+-----------------------------------------------------------+\n</code></pre></p> <p>Fields:</p> Name Type Description <code>Type</code> <code>uint8_t</code> Packet type identifier (see Message Types) <code>Size</code> <code>uint32_t</code> Total size of the packet in bytes, including the header <p>All packets are 8-byte aligned (<code>alignas(8)</code>).</p>"},{"location":"server_protocol/#5-message-types","title":"5. Message Types","text":"<p>Each packet begins with a <code>PacketHeader</code>, followed by a type-specific payload.</p>"},{"location":"server_protocol/#packettype-enumeration","title":"PacketType Enumeration","text":"Value Name Direction <code>0x01</code> ChatMessage Both <code>0x02</code> PlayerMove Server \u2192 Client <code>0x03</code> NewPlayer Server \u2192 Client <code>0x04</code> PlayerInfo Client \u2192 Server <code>0x05</code> EnemySpawn Server \u2192 Client <code>0x06</code> EnemyMove Server \u2192 Client <code>0x07</code> EnemyDeath Server \u2192 Client <code>0x08</code> PlayerShoot Client \u2192 Server <code>0x09</code> ProjectileSpawn Server \u2192 Client <code>0x0A</code> ProjectileHit Server \u2192 Client <code>0x0B</code> ProjectileDestroy Server \u2192 Client <code>0x0C</code> GameStart Server \u2192 Client <code>0x0D</code> GameEnd Server \u2192 Client <code>0x0E</code> PlayerDisconnected Both <code>0x0F</code> Heartbeat Client \u2192 Server <code>0x10</code> EnemyHit Server \u2192 Client <code>0x11</code> PlayerHit Client \u2192 Server <code>0x12</code> PlayerDeath Server \u2192 Client <code>0x13</code> CreateRoom Client \u2192 Server <code>0x14</code> JoinRoom Client \u2192 Server <code>0x15</code> LeaveRoom Client \u2192 Server <code>0x16</code> ListRoom Client \u2192 Server <code>0x17</code> ListRoomResponse Server \u2192 Client <code>0x18</code> MatchmakingRequest Client \u2192 Server <code>0x19</code> MatchmakingResponse Server \u2192 Client <code>0x1A</code> JoinRoomResponse Server \u2192 Client <code>0x1B</code> PlayerInput Client \u2192 Server <code>0x1C</code> Ack Both <code>0x1D</code> RequestChallenge Client \u2192 Server <code>0x1E</code> ChallengeResponse Server \u2192 Client <code>0x1F</code> CreateRoomResponse Server \u2192 Client"},{"location":"server_protocol/#51-common-messages","title":"5.1. Common Messages","text":""},{"location":"server_protocol/#chatmessage-0x01","title":"ChatMessage (0x01)","text":"<p>Sends a chat message with timestamp and color information.</p> Field Type Description <code>timestamp</code> <code>uint32_t</code> Message timestamp <code>message</code> <code>char[512]</code> UTF-8 message text (max 511 bytes) <code>player_id</code> <code>uint32_t</code> Sender's player ID <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code> <code>uint8_t</code> RGBA color values (0-255) <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#52-client-to-server-messages","title":"5.2. Client-to-Server Messages","text":""},{"location":"server_protocol/#playerinfo-0x04","title":"PlayerInfo (0x04)","text":"<p>Provides the player's display name.</p> Field Type Description <code>name</code> <code>char[32]</code> Null-terminated UTF-8 string (max 31 bytes) <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#playershoot-0x08","title":"PlayerShoot (0x08)","text":"<p>Notifies the server that the player fired a projectile.</p> Field Type Description <code>x</code>, <code>y</code> <code>float</code> Projectile origin <code>projectile_type</code> <code>uint8_t</code> Projectile type (e.g. PLAYER_BASIC) <code>sequence_number</code> <code>uint32_t</code> Sequence number"},{"location":"server_protocol/#playerhit-0x11","title":"PlayerHit (0x11)","text":"<p>Reports that the player was hit.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Player identifier <code>damage</code> <code>uint32_t</code> Damage amount <code>x</code>, <code>y</code> <code>float</code> Hit position <code>sequence_number</code> <code>uint32_t</code> Sequence number for ordering"},{"location":"server_protocol/#playerdisconnect-0x0e","title":"PlayerDisconnect (0x0E)","text":"<p>Sent when a client disconnects gracefully.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Identifier of the disconnecting player <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#heartbeat-0x0f","title":"Heartbeat (0x0F)","text":"<p>Keep-alive packet to maintain UDP connectivity.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Player identifier"},{"location":"server_protocol/#playerinput-0x1b","title":"PlayerInput (0x1B)","text":"<p>Sends player movement input as a bitfield.</p> Field Type Description <code>input</code> <code>uint8_t</code> Bitfield of MovementInputType flags <code>sequence_number</code> <code>uint32_t</code> Client-side input sequence number"},{"location":"server_protocol/#53-server-to-client-messages","title":"5.3. Server-to-Client Messages","text":""},{"location":"server_protocol/#newplayer-0x03","title":"NewPlayer (0x03)","text":"<p>Announces a new player to connected clients.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Player ID <code>player_name</code> <code>char[32]</code> Player display name (max 31 bytes) <code>x</code>, <code>y</code> <code>float</code> Spawn position <code>speed</code> <code>float</code> Movement speed <code>sequence_number</code> <code>uint32_t</code> Packet sequence number <code>max_health</code> <code>uint32_t</code> Max health points"},{"location":"server_protocol/#playermove-0x02","title":"PlayerMove (0x02)","text":"<p>Updates a player's position.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Target player ID <code>sequence_number</code> <code>uint32_t</code> Movement order number <code>x</code>, <code>y</code> <code>float</code> New position"},{"location":"server_protocol/#enemyspawn-0x05","title":"EnemySpawn (0x05)","text":"<p>Spawns a new enemy entity.</p> Field Type Description <code>enemy_id</code> <code>uint32_t</code> Unique enemy ID <code>enemy_type</code> <code>uint8_t</code> Enemy type (e.g. BASIC_FIGHTER) <code>x</code>, <code>y</code> <code>float</code> Spawn position <code>velocity_x</code>, <code>velocity_y</code> <code>float</code> Movement velocity <code>sequence_number</code> <code>uint32_t</code> Packet sequence number <code>health</code>, <code>max_health</code> <code>uint32_t</code> Current and max health"},{"location":"server_protocol/#enemymove-0x06","title":"EnemyMove (0x06)","text":"<p>Updates enemy movement and position.</p> Field Type Description <code>enemy_id</code> <code>uint32_t</code> Unique identifier of the enemy <code>x</code>, <code>y</code> <code>float</code> Current enemy position <code>velocity_x</code>, <code>velocity_y</code> <code>float</code> Current enemy velocity vector <code>sequence_number</code> <code>uint32_t</code> Sequence number for ordering updates"},{"location":"server_protocol/#enemydeath-0x07","title":"EnemyDeath (0x07)","text":"<p>Signals that an enemy was destroyed.</p> Field Type Description <code>enemy_id</code> <code>uint32_t</code> Identifier of the enemy that died <code>death_x</code>, <code>death_y</code> <code>float</code> World coordinates where the death occurred <code>player_id</code> <code>uint32_t</code> Player who killed the enemy <code>score</code> <code>uint32_t</code> Score awarded for the kill <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#enemyhit-0x10","title":"EnemyHit (0x10)","text":"<p>Reports that an enemy took damage.</p> Field Type Description <code>enemy_id</code> <code>uint32_t</code> Identifier of the enemy hit <code>hit_x</code>, <code>hit_y</code> <code>float</code> Coordinates where the hit occurred <code>damage</code> <code>float</code> Damage dealt to the enemy <code>sequence_number</code> <code>uint32_t</code> Sequence number for event ordering"},{"location":"server_protocol/#projectilespawn-0x09","title":"ProjectileSpawn (0x09)","text":"<p>Creates a projectile in the client world.</p> Field Type Description <code>projectile_id</code> <code>uint32_t</code> Unique identifier of the projectile <code>projectile_type</code> <code>uint8_t</code> Projectile type (PLAYER_BASIC or ENEMY_BASIC) <code>owner_id</code> <code>uint32_t</code> Entity ID of the projectile's owner <code>is_enemy_projectile</code> <code>uint8_t</code> <code>1</code> if fired by an enemy, otherwise <code>0</code> <code>x</code>, <code>y</code> <code>float</code> Initial position of the projectile <code>velocity_x</code>, <code>velocity_y</code> <code>float</code> Direction and velocity vector <code>speed</code> <code>float</code> Projectile speed scalar <code>sequence_number</code> <code>uint32_t</code> Packet sequence number <code>damage</code> <code>uint32_t</code> Damage caused on impact"},{"location":"server_protocol/#projectilehit-0x0a","title":"ProjectileHit (0x0A)","text":"<p>Notifies that a projectile hit an entity.</p> Field Type Description <code>projectile_id</code> <code>uint32_t</code> Identifier of the projectile that hit <code>target_id</code> <code>uint32_t</code> Entity ID of the impacted target <code>target_is_player</code> <code>uint8_t</code> <code>1</code> if the target is a player, <code>0</code> if enemy <code>hit_x</code>, <code>hit_y</code> <code>float</code> Coordinates of the hit point"},{"location":"server_protocol/#projectiledestroy-0x0b","title":"ProjectileDestroy (0x0B)","text":"<p>Removes a projectile from the world.</p> Field Type Description <code>projectile_id</code> <code>uint32_t</code> Identifier of the projectile to remove <code>x</code>, <code>y</code> <code>float</code> Position where the projectile was destroyed <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#playerdeath-0x12","title":"PlayerDeath (0x12)","text":"<p>Informs clients that a player has died.</p> Field Type Description <code>player_id</code> <code>uint32_t</code> Identifier of the deceased player <code>x</code>, <code>y</code> <code>float</code> Coordinates of the death location <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#gamestart-0x0c","title":"GameStart (0x0C)","text":"<p>Signals the start of the game.</p> Field Type Description <code>sequence_number</code> <code>uint32_t</code> Packet sequence number <code>game_start</code> <code>uint8_t</code> <code>1</code> if the game has started, <code>0</code> otherwise"},{"location":"server_protocol/#gameend-0x0d","title":"GameEnd (0x0D)","text":"<p>Signals the end of the game.</p> Field Type Description <code>sequence_number</code> <code>uint32_t</code> Packet sequence number <code>game_end</code> <code>uint8_t</code> <code>1</code> if the game has ended, <code>0</code> otherwise"},{"location":"server_protocol/#54-room-management-messages","title":"5.4. Room Management Messages","text":""},{"location":"server_protocol/#createroom-0x13","title":"CreateRoom (0x13)","text":"<p>Requests creation of a new game room.</p> Field Type Description <code>room_name</code> <code>char[32]</code> Room display name (max 31 bytes) <code>is_private</code> <code>uint8_t</code> <code>1</code> for private (password required), <code>0</code> for public <code>password</code> <code>char[32]</code> Password for private rooms (max 31 bytes) <code>max_players</code> <code>uint8_t</code> Maximum number of players allowed <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#createroomresponse-0x1f","title":"CreateRoomResponse (0x1F)","text":"<p>Server response to a CreateRoom request.</p> Field Type Description <code>error_code</code> <code>uint8_t</code> RoomError result code <code>room_id</code> <code>uint32_t</code> Assigned room ID (valid when SUCCESS) <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#joinroom-0x14","title":"JoinRoom (0x14)","text":"<p>Requests to join an existing room.</p> Field Type Description <code>room_id</code> <code>uint32_t</code> Target room identifier <code>password</code> <code>char[64]</code> Room password or hash (max 63 bytes) <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#joinroomresponse-0x1a","title":"JoinRoomResponse (0x1A)","text":"<p>Server response to a JoinRoom request.</p> Field Type Description <code>error_code</code> <code>uint8_t</code> RoomError result code <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#leaveroom-0x15","title":"LeaveRoom (0x15)","text":"<p>Requests to leave the current room.</p> Field Type Description <code>room_id</code> <code>uint32_t</code> Room identifier to leave"},{"location":"server_protocol/#listroom-0x16","title":"ListRoom (0x16)","text":"<p>Requests a list of available rooms.</p> <p>No payload beyond header.</p>"},{"location":"server_protocol/#listroomresponse-0x17","title":"ListRoomResponse (0x17)","text":"<p>Server response containing available rooms.</p> Field Type Description <code>room_count</code> <code>uint32_t</code> Number of valid room entries <code>rooms</code> <code>RoomInfo[MAX_ROOMS]</code> Array of room information structures <p>RoomInfo Structure:</p> Field Type Description <code>room_id</code> <code>uint32_t</code> Unique room identifier <code>room_name</code> <code>char[32]</code> Room display name <code>player_count</code> <code>uint8_t</code> Current number of players <code>max_players</code> <code>uint8_t</code> Maximum allowed players"},{"location":"server_protocol/#matchmakingrequest-0x18","title":"MatchmakingRequest (0x18)","text":"<p>Requests automatic matchmaking into a suitable room.</p> Field Type Description <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#matchmakingresponse-0x19","title":"MatchmakingResponse (0x19)","text":"<p>Server response to matchmaking request.</p> Field Type Description <code>error_code</code> <code>uint8_t</code> RoomError result code <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#55-acknowledgment-messages","title":"5.5. Acknowledgment Messages","text":""},{"location":"server_protocol/#ack-0x1c","title":"Ack (0x1C)","text":"<p>Acknowledges receipt of a sequenced packet.</p> Field Type Description <code>sequence_number</code> <code>uint32_t</code> Sequence number being acknowledged <code>player_id</code> <code>uint32_t</code> Player ID associated with the acknowledgment"},{"location":"server_protocol/#requestchallenge-0x1d","title":"RequestChallenge (0x1D)","text":"<p>Requests a challenge string for password verification.</p> Field Type Description <code>room_id</code> <code>uint32_t</code> Room for which challenge is requested <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#challengeresponse-0x1e","title":"ChallengeResponse (0x1E)","text":"<p>Server provides a challenge string and timestamp.</p> Field Type Description <code>challenge</code> <code>char[128]</code> Challenge string for hashing (max 127 bytes) <code>timestamp</code> <code>uint32_t</code> Challenge creation timestamp (epoch seconds) <code>sequence_number</code> <code>uint32_t</code> Packet sequence number"},{"location":"server_protocol/#6-data-types","title":"6. Data Types","text":"Type Description <code>uint8_t</code>, <code>uint32_t</code> Unsigned integers, little-endian <code>float</code> IEEE 754 single-precision, little-endian <code>char[]</code> UTF-8 encoded string, null-terminated Alignment All packets are 8-byte aligned (<code>alignas(8)</code>) <p>String Serialization Limits:</p> Field Size Constant Description 32 bytes <code>SERIALIZE_32_BYTES</code> Short strings (names, etc.) 64 bytes <code>SERIALIZE_64_BYTES</code> Passwords and hashes 128 bytes <code>SERIALIZE_128_BYTES</code> Challenge strings 512 bytes <code>SERIALIZE_512_BYTES</code> Chat messages"},{"location":"server_protocol/#7-enumeration-types","title":"7. Enumeration Types","text":""},{"location":"server_protocol/#enemytype","title":"EnemyType","text":"Value Name Description <code>0x01</code> BASIC_FIGHTER Standard enemy type"},{"location":"server_protocol/#projectiletype","title":"ProjectileType","text":"Value Name Description <code>0x01</code> PLAYER_BASIC Standard player projectile <code>0x02</code> ENEMY_BASIC Standard enemy projectile"},{"location":"server_protocol/#roomerror","title":"RoomError","text":"Value Name Description <code>0x00</code> SUCCESS Operation succeeded <code>0x01</code> ROOM_NOT_FOUND Requested room does not exist <code>0x02</code> ROOM_FULL Room has reached maximum capacity <code>0x03</code> WRONG_PASSWORD Invalid password provided <code>0x04</code> ALREADY_IN_ROOM Player is already in a room <code>0x05</code> PLAYER_BANNED Player is banned from the room <code>0x06</code> UNKNOWN_ERROR Unspecified error occurred"},{"location":"server_protocol/#movementinputtype-bitfield","title":"MovementInputType (Bitfield)","text":"Value Name Description <code>1 &lt;&lt; 0</code> UP Move up <code>1 &lt;&lt; 1</code> DOWN Move down <code>1 &lt;&lt; 2</code> LEFT Move left <code>1 &lt;&lt; 3</code> RIGHT Move right"},{"location":"server_protocol/#8-message-semantics","title":"8. Message Semantics","text":""},{"location":"server_protocol/#general-rules","title":"General Rules","text":"<ul> <li>The server MUST validate the <code>size</code> field of all packets.  </li> <li>Clients MUST NOT send unknown or malformed packet types.  </li> <li>Sequence numbers SHOULD be used to detect dropped or out-of-order UDP packets.  </li> <li>The server MAY ignore packets received out of sequence.  </li> <li>The client MUST periodically send a <code>Heartbeat</code> packet to prevent timeout.</li> </ul>"},{"location":"server_protocol/#acknowledgment-system","title":"Acknowledgment System","text":"<p>Critical packets requiring acknowledgment include: - ChatMessage - NewPlayer - PlayerDisconnect - EnemySpawn - EnemyDeath - ProjectileSpawn - ProjectileDestroy - GameStart - PlayerShoot - JoinRoomResponse - MatchmakingResponse - ChallengeResponse - CreateRoomResponse</p> <p>When a packet requires acknowledgment: 1. The sender stores the packet with its sequence number 2. The receiver sends an Ack packet upon successful processing 3. The sender removes the packet from unacknowledged storage upon receiving the Ack 4. Unacknowledged packets MAY be retransmitted after a timeout</p>"},{"location":"server_protocol/#room-password-security","title":"Room Password Security","text":"<p>For password-protected rooms: 1. Client requests challenge via <code>RequestChallenge</code> 2. Server responds with <code>ChallengeResponse</code> containing a random challenge string 3. Client hashes the password with the challenge: <code>hash(password + challenge + timestamp)</code> 4. Client sends the hash in the <code>JoinRoom</code> password field 5. Server validates by computing the same hash</p>"},{"location":"server_protocol/#9-example-exchange","title":"9. Example Exchange","text":""},{"location":"server_protocol/#initial-connection-and-room-join","title":"Initial Connection and Room Join","text":"<p>Client \u2192 Server: <pre><code>PlayerInfo (name=\"Alice\", seq=1)\n</code></pre></p> <p>Server \u2192 Client: <pre><code>Ack (seq=1, player_id=1)\n</code></pre></p> <p>Client \u2192 Server: <pre><code>MatchmakingRequest (seq=2)\n</code></pre></p> <p>Server \u2192 Client: <pre><code>Ack (seq=2, player_id=1)\nMatchmakingResponse (error_code=SUCCESS, seq=100)\nNewPlayer (id=1, name=\"Alice\", x=100, y=200, seq=101)\n</code></pre></p> <p>Client \u2192 Server: <pre><code>Ack (seq=100, player_id=1)\nAck (seq=101, player_id=1)\n</code></pre></p>"},{"location":"server_protocol/#gameplay","title":"Gameplay","text":"<p>Client \u2192 Server: <pre><code>PlayerInput (input=UP|RIGHT, seq=3)\nPlayerShoot (x=100, y=200, type=PLAYER_BASIC, seq=4)\nHeartbeat (player_id=1)\n</code></pre></p> <p>Server \u2192 Client: <pre><code>PlayerMove (id=1, x=105, y=195, seq=102)\nProjectileSpawn (id=99, owner=1, type=PLAYER_BASIC, seq=103)\nEnemySpawn (id=42, type=BASIC_FIGHTER, x=500, y=100, seq=104)\n</code></pre></p> <p>Client \u2192 Server: <pre><code>Ack (seq=103, player_id=1)\nAck (seq=104, player_id=1)\n</code></pre></p>"},{"location":"server_protocol/#10-security-considerations","title":"10. Security Considerations","text":"<p>The R-Type protocol provides basic authentication through challenge-response for room passwords but no encryption.  </p> <p>Known Vulnerabilities: - Packets can be intercepted and read in plaintext - No protection against replay attacks beyond challenge timeout - No integrity checks or packet signing - Denial-of-service attacks possible via packet flooding</p> <p>The protocol SHOULD be used only in controlled or local environments. Future revisions MAY introduce: - TLS/DTLS for encryption - HMAC for message authentication - Rate limiting and flood protection - Session tokens and player authentication</p>"},{"location":"server_protocol/#11-future-work","title":"11. Future Work","text":"<ul> <li>Add optional reliable UDP transport layer.  </li> <li>Support encryption for secure communication (DTLS).  </li> <li>Expand enemy and projectile type definitions.  </li> <li>Introduce session tokens and centralized player authentication.</li> <li>Add spectator mode support.</li> <li>Implement voice chat capability.</li> <li>Add replay recording and playback support.</li> </ul>"},{"location":"server_protocol/#appendix-a-packet-layouts","title":"Appendix A. Packet Layouts","text":"<p>See <code>Packet.hpp</code> for complete C++ structure definitions. All packets are defined with <code>alignas(8)</code> to ensure consistent binary layout across architectures.</p>"},{"location":"server_protocol/#serialization","title":"Serialization","text":"<p>Packets are serialized using the Bitsery library with the following conventions: - 1-byte values: <code>s.value1b(field)</code> - 4-byte values: <code>s.value4b(field)</code> - Floats: <code>s.template value&lt;sizeof(float)&gt;(field)</code> - Strings: <code>s.text1b(field, SIZE_CONSTANT)</code></p> <p>All integer types use little-endian byte order.</p>"},{"location":"server_protocol/#authors","title":"Authors","text":"<p>Arthur GUERINAULT, Nolann DUBOS, Quentin LAPIERRE, Etienne LABARBE, Robin CHASSAGNE R-Type Project November 2025</p>"},{"location":"wiki/AssetManagement/","title":"Asset Management","text":"<p>This section details how game assets (sprites, backgrounds, etc.) are managed and loaded within the R-Type project, primarily focusing on the client-side implementation.</p>"},{"location":"wiki/AssetManagement/#overview","title":"Overview","text":"<p>The R-Type client employs an <code>AssetManager</code> to handle the loading and management of various game assets, such as textures and images. A key feature of this system is the ability to embed assets directly into the executable at compile-time, reducing reliance on external files at runtime. This is particularly useful for ensuring all necessary assets are present and loaded efficiently.</p>"},{"location":"wiki/AssetManagement/#assetmanager-clientassetmanagerhpp","title":"<code>AssetManager</code> (<code>client/AssetManager.hpp</code>)","text":"<p>The <code>asset::AssetManager</code> class is responsible for:</p> <ul> <li>Embedded Asset Handling: It can export image files as C header files (<code>exportImageAsCode</code>) which contain the image data as static arrays. These embedded assets can then be registered (<code>registerEmbeddedImage</code>) and loaded at runtime using a special <code>embedded://</code> scheme.</li> <li>Runtime Loading: Provides methods (<code>loadTexture</code>, <code>loadImage</code>) to load assets. It first attempts to load from embedded data; if not found or if the path doesn't use the <code>embedded://</code> scheme, it falls back to loading from the file system.</li> <li>Texture and Image Management: Utilizes <code>raylib</code> functions for handling <code>Texture2D</code> and <code>Image</code> types.</li> </ul>"},{"location":"wiki/AssetManagement/#key-methods","title":"Key Methods:","text":"<ul> <li><code>static bool exportImageAsCode(const std::string &amp;imagePath, const std::string &amp;outputHeaderPath)</code>: Exports an image to a C header file for embedding.</li> <li><code>static Texture2D loadTexture(const std::string &amp;path)</code>: Loads a texture, prioritizing embedded assets.</li> <li><code>static Image loadImage(const std::string &amp;path)</code>: Loads an image, prioritizing embedded assets.</li> <li><code>static void registerEmbeddedImage(const std::string &amp;name, void *data, int width, int height, int format)</code>: Registers an embedded image with a given name and its properties.</li> </ul>"},{"location":"wiki/AssetManagement/#rendermanager-clientrendermanagerhpp","title":"<code>RenderManager</code> (<code>client/RenderManager.hpp</code>)","text":"<p>The <code>renderManager::Renderer</code> class, while primarily focused on rendering operations, defines constants for the paths to various core game assets. These paths often point to embedded assets, indicating their importance and how they are accessed by the rendering system.</p>"},{"location":"wiki/AssetManagement/#asset-paths-defined","title":"Asset Paths Defined:","text":"<ul> <li><code>WINDOW_WIDTH</code>, <code>WINDOW_HEIGHT</code>: Window dimensions.</li> <li><code>SCROLL_SPEED</code>: Speed for background scrolling.</li> <li><code>BG_PATH</code>: Path to the background asset (e.g., <code>embedded://background</code>).</li> <li><code>PLAYER_PATH</code>: Path to the player spritesheet (e.g., <code>embedded://players</code>).</li> <li><code>PROJECTILE_PATH</code>: Path to the projectile spritesheet (e.g., <code>embedded://projectiles</code>).</li> <li><code>ENEMY_PATH</code>: Path to the enemy spritesheet (e.g., <code>embedded://enemy</code>).</li> </ul>"},{"location":"wiki/AssetManagement/#asset-resources-clientresources","title":"Asset Resources (<code>client/resources/</code>)","text":"<p>This directory contains the raw image files that are used as game assets. These files are typically processed by the <code>AssetManager</code> (e.g., embedded) or loaded directly at runtime.</p>"},{"location":"wiki/AssetManagement/#contents","title":"Contents:","text":"<ul> <li><code>background.png</code>: The main background image for the game.</li> <li><code>enemies.gif</code>: Spritesheet or animation for enemy characters.</li> <li><code>players.gif</code>: Spritesheet or animation for player characters.</li> <li><code>projectiles.gif</code>: Spritesheet or animation for projectiles.</li> <li><code>start_screen.png</code>: Image for the game's start screen.</li> </ul> <p>By combining embedded assets with a fallback to file-system loading, the R-Type client ensures efficient asset delivery and flexibility during development.</p>"},{"location":"wiki/ContributionGuidelines/","title":"Contribution Guidelines","text":"<p>We welcome and appreciate contributions to the R-Type project! By contributing, you help make this project better for everyone. Please take a moment to review this document to understand how to contribute effectively.</p>"},{"location":"wiki/ContributionGuidelines/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the Repository: Start by forking the main R-Type repository to your GitHub account.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.     <pre><code>git clone https://github.com/YourUsername/CPP-Advanced_C---R-Type.git\ncd CPP-Advanced_C---R-Type\n</code></pre></li> <li>Create a New Branch: Create a new branch for your feature or bug fix. Use a descriptive name (e.g., <code>feature/add-new-enemy-type</code>, <code>bugfix/fix-player-collision</code>).     <pre><code>git checkout -b your-branch-name\n</code></pre></li> <li>Make Your Changes: Implement your feature or fix the bug. Ensure your code adheres to the project's coding style and conventions.</li> <li>Test Your Changes: If applicable, add or update unit tests to cover your changes. Ensure all existing tests pass.</li> <li>Commit Your Changes: Write clear, concise commit messages. A good commit message explains what was changed and why.     <pre><code>git commit -m \"feat: Add new enemy type with unique attack pattern\"\n</code></pre></li> <li>Push to Your Fork: Push your local branch to your forked repository on GitHub.     <pre><code>git push origin your-branch-name\n</code></pre></li> <li>Create a Pull Request (PR): Go to the original R-Type repository on GitHub and create a new Pull Request from your forked branch. Provide a detailed description of your changes, including any relevant issue numbers.</li> </ol>"},{"location":"wiki/ContributionGuidelines/#coding-style-and-conventions","title":"Coding Style and Conventions","text":"<ul> <li>Follow Existing Style: Please adhere to the existing coding style and conventions found in the codebase. This includes naming conventions, indentation, brace style, and comment formatting.</li> <li>C++17 Standard: All new code should be compatible with the C++17 standard.</li> <li>Clear and Readable Code: Write code that is easy to understand and maintain.</li> <li>Comments: Add comments where necessary to explain complex logic or non-obvious decisions. Avoid commenting on obvious code.</li> </ul>"},{"location":"wiki/ContributionGuidelines/#testing","title":"Testing","text":"<ul> <li>Unit Tests: For new features or bug fixes, please include relevant unit tests. This helps ensure the stability and correctness of the codebase.</li> <li>Build System: Ensure your changes build successfully using CMake and Conan.</li> </ul>"},{"location":"wiki/ContributionGuidelines/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Descriptive Title: Your PR title should briefly summarize the changes.</li> <li>Detailed Description: Provide a clear and concise description of your changes. Explain the problem your PR solves, how it solves it, and any potential impacts.</li> <li>Refer to Issues: If your PR addresses an existing issue, please link to it (e.g., <code>Fixes #123</code>, <code>Closes #456</code>).</li> <li>Code Review: Be prepared for constructive feedback during the code review process. Address comments and make necessary adjustments.</li> </ul>"},{"location":"wiki/ContributionGuidelines/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, please open an issue on the GitHub issue tracker. Provide as much detail as possible, including:</p> <ul> <li>A clear and concise description of the bug.</li> <li>Steps to reproduce the behavior.</li> <li>Expected behavior.</li> <li>Screenshots or error messages, if applicable.</li> <li>Your operating system and compiler version.</li> </ul> <p>Thank you for your contributions!</p>"},{"location":"wiki/GameEngineECS/","title":"Game Engine (ECS)","text":"<p>This section describes the Entity-Component-System (ECS) architecture implemented in the R-Type game engine. The ECS pattern promotes a clear separation of concerns, leading to more flexible, scalable, and maintainable game logic.</p>"},{"location":"wiki/GameEngineECS/#core-concepts","title":"Core Concepts","text":"<p>The R-Type ECS is built around three fundamental concepts:</p> <ul> <li>Entities: Represent unique game objects (e.g., a player, an enemy, a projectile). An entity is essentially just a unique ID.</li> <li>Components: Raw data associated with an entity (e.g., <code>PositionComponent</code>, <code>HealthComponent</code>, <code>SpriteComponent</code>). Components contain no logic; they only store data.</li> <li>Systems: Logic that operates on entities that possess a specific set of components (e.g., <code>MovementSystem</code> operates on entities with <code>PositionComponent</code> and <code>VelocityComponent</code>). Systems perform actions and modify component data.</li> </ul>"},{"location":"wiki/GameEngineECS/#architecture-overview","title":"Architecture Overview","text":"<p>The ECS implementation consists of several key managers:</p>"},{"location":"wiki/GameEngineECS/#ecsmanager","title":"<code>ECSManager</code>","text":"<p>The <code>ECSManager</code> is the central orchestrator of the entire ECS. It provides the main interface for interacting with the ECS, abstracting away the complexities of the underlying managers. It is responsible for:</p> <ul> <li>Creating and destroying entities.</li> <li>Registering component types.</li> <li>Adding and removing components from entities.</li> <li>Retrieving components from entities.</li> <li>Registering and setting signatures for systems.</li> <li>Triggering the update cycle for all registered systems.</li> </ul>"},{"location":"wiki/GameEngineECS/#entitymanager","title":"<code>EntityManager</code>","text":"<p>The <code>EntityManager</code> is responsible for managing the lifecycle of entities. It:</p> <ul> <li>Assigns unique IDs to new entities.</li> <li>Recycles IDs of destroyed entities.</li> <li>Maintains a <code>Signature</code> for each entity, which is a bitset indicating which components are attached to that entity.</li> </ul>"},{"location":"wiki/GameEngineECS/#componentmanager","title":"<code>ComponentManager</code>","text":"<p>The <code>ComponentManager</code> handles the registration and storage of different component types. Key features include:</p> <ul> <li>Component Registration: Allows new component types to be registered with the ECS.</li> <li>Data-Oriented Storage: Components of the same type are stored contiguously in memory using <code>std::array&lt;T, MAX_ENTITIES&gt;</code> within <code>ecs::Component&lt;T&gt;</code>, improving cache performance.</li> <li>Component Operations: Provides methods to add, remove, and retrieve components for specific entities.</li> </ul>"},{"location":"wiki/GameEngineECS/#systemmanager","title":"<code>SystemManager</code>","text":"<p>The <code>SystemManager</code> is responsible for managing all the systems in the ECS. It:</p> <ul> <li>System Registration: Allows new systems to be registered.</li> <li>System Signatures: Each system has a <code>Signature</code> that defines the set of components an entity must possess for the system to process it. When an entity's components change, the <code>SystemManager</code> updates which entities each system is interested in.</li> <li>System Updates: Iterates through all registered systems and calls their <code>update</code> method, passing the <code>deltaTime</code>.</li> </ul>"},{"location":"wiki/GameEngineECS/#system-base-class","title":"<code>System</code> Base Class","text":"<p>All systems inherit from the <code>ecs::System</code> base class. A system typically:</p> <ul> <li>Maintains a <code>std::set&lt;Entity&gt;</code> of entities that match its signature.</li> <li>Implements an <code>update(float deltaTime)</code> method where its logic is executed. This method iterates over the entities in its set and performs operations based on their components.</li> </ul>"},{"location":"wiki/GameEngineECS/#how-it-works-together","title":"How it Works Together","text":"<ol> <li>Initialization: The <code>ECSManager</code> is initialized, which in turn initializes the <code>EntityManager</code>, <code>ComponentManager</code>, and <code>SystemManager</code>.</li> <li>Entity Creation: When <code>createEntity()</code> is called, the <code>EntityManager</code> provides a new unique ID.</li> <li>Component Attachment: When <code>addComponent()</code> is called, the <code>ComponentManager</code> stores the component data, and the <code>EntityManager</code> updates the entity's <code>Signature</code>. The <code>SystemManager</code> is then notified to update which systems are interested in this entity.</li> <li>System Logic: During each game loop iteration, <code>ECSManager::update()</code> calls <code>SystemManager::update()</code>, which then calls the <code>update()</code> method of each registered system. Each system then processes the entities that match its signature.</li> <li>Entity Destruction: When <code>destroyEntity()</code> is called, the <code>ECSManager</code> orchestrates the removal of all components associated with the entity and notifies systems to remove the entity from their processing sets.</li> </ol> <p>This modular design allows for easy addition of new game features by simply creating new components and systems without modifying existing code.</p>"},{"location":"wiki/GettingStarted/","title":"Getting Started","text":"<p>This guide will walk you through the process of building and running the R-Type client and server.</p>"},{"location":"wiki/GettingStarted/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>CMake: Version 3.15 or higher.</li> <li>Conan: For dependency management.</li> <li>C++ Compiler: A C++17 compatible compiler (e.g., GCC, Clang, MSVC).</li> <li>Git: For cloning the repository.</li> </ul>"},{"location":"wiki/GettingStarted/#building-the-project","title":"Building the Project","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/EpitechPromo2027/CPP-Advanced_C---R-Type.git\ncd CPP-Advanced_C---R-Type\n</code></pre> </li> <li> <p>Build the project</p> <pre><code>./build.sh\n</code></pre> <p>This will build both the client and server executables.</p> </li> </ol>"},{"location":"wiki/GettingStarted/#running-the-server","title":"Running the Server","text":"<ol> <li> <p>Run the server:</p> <pre><code>./r-type_server\n</code></pre> </li> </ol>"},{"location":"wiki/GettingStarted/#running-the-client","title":"Running the Client","text":"<ol> <li> <p>Run the client:</p> <pre><code>./r-type_client\n</code></pre> </li> </ol>"},{"location":"wiki/Home/","title":"R-Type Project","text":"<p>Welcome to the R-Type project wiki! This document provides an overview of the project, its architecture, and how to get started.</p>"},{"location":"wiki/Home/#overview","title":"Overview","text":"<p>This project is a re-implementation of the classic arcade game R-Type, built with a focus on a modular and extensible architecture using an Entity-Component-System (ECS) pattern. It features both a client and a server component, allowing for networked multiplayer gameplay.</p>"},{"location":"wiki/Home/#features","title":"Features","text":"<ul> <li>Client-Server Architecture: Dedicated server for game logic and client for rendering and user interaction.</li> <li>Entity-Component-System (ECS): A flexible and powerful architecture for game entities and their behaviors.</li> <li>Networked Gameplay: Supports multiple players connecting to a central server.</li> <li>Asset Management: Efficient handling of game assets like sprites and backgrounds.</li> <li>Cross-platform: Designed to be runnable on various operating systems.</li> </ul>"},{"location":"wiki/Home/#project-structure","title":"Project Structure","text":"<p>The project is organized into several key directories:</p> <ul> <li><code>client/</code>: Contains all client-side specific code, including rendering, input handling, and client-side networking.</li> <li><code>server/</code>: Contains all server-side specific code, including game logic, entity management, and server-side networking.</li> <li><code>core/</code>: Shared utilities and networking components used by both client and server.</li> <li><code>game_engine/</code>: The core ECS implementation, including components, systems, and managers.</li> <li><code>docs/</code>: Project documentation, including protocol specifications and server setup guides.</li> </ul>"},{"location":"wiki/Home/#getting-started","title":"Getting Started","text":"<p>Please refer to the Getting Started page for detailed instructions on how to build and run the project.</p>"},{"location":"wiki/Home/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see the Contribution Guidelines for more information.</p>"},{"location":"wiki/Home/#technical-details","title":"Technical Details","text":"<p>For more in-depth technical information, explore the following sections:</p> <ul> <li>Game Engine (ECS)</li> <li>Networking</li> <li>Asset Management</li> </ul>"},{"location":"wiki/Networking/","title":"Networking","text":"<p>This page explains the networking architecture and protocols used in the R-Type client-server communication.</p>"},{"location":"wiki/Networking/#overview","title":"Overview","text":"<p>The R-Type project utilizes a UDP-based client-server architecture for real-time multiplayer gameplay. This choice prioritizes low-latency communication, which is crucial for fast-paced action games, over guaranteed delivery. Both the client and server implement their own mechanisms for sequencing and re-synchronization to handle UDP's unreliable nature.</p>"},{"location":"wiki/Networking/#core-components","title":"Core Components","text":""},{"location":"wiki/Networking/#basenetworkmanager","title":"<code>BaseNetworkManager</code>","text":"<p>Located in <code>core/network/BaseNetworkManager.hpp</code>, this abstract base class provides the fundamental functionalities for network communication using <code>asio</code> (Boost.Asio or Standalone Asio). It sets up a UDP socket and defines the basic interface for sending and receiving data.</p> <p>Key responsibilities: *   Initialization of an <code>asio::io_context</code> and a <code>asio::ip::udp::socket</code>. *   Provides virtual methods for <code>startReceive</code>, <code>send</code>, <code>run</code>, and <code>stop</code> that concrete network managers must implement. *   Manages a receive buffer (<code>_recv_buffer</code>).</p>"},{"location":"wiki/Networking/#clientnetworkmanager","title":"<code>ClientNetworkManager</code>","text":"<p>Implemented in <code>core/network/ClientNetworkManager.hpp</code>, this class extends <code>BaseNetworkManager</code> and handles all client-side networking logic. It connects to a specific server and manages the sending of player actions and receiving of game state updates.</p> <p>Key responsibilities: *   Connecting to a remote server endpoint. *   Sending client-specific packets (e.g., player movement, shoot events). *   Receiving and processing server-sent packets. *   Managing connection state (e.g., <code>isConnected</code>).</p>"},{"location":"wiki/Networking/#servernetworkmanager","title":"<code>ServerNetworkManager</code>","text":"<p>Implemented in <code>core/network/ServerNetworkManager.hpp</code>, this class also extends <code>BaseNetworkManager</code> and manages all server-side networking logic. It listens for incoming client connections, registers clients, and broadcasts game state updates.</p> <p>Key responsibilities: *   Listening for incoming UDP packets from multiple clients. *   Registering and unregistering clients, mapping client IDs to their network endpoints. *   Sending specific packets to individual clients or broadcasting to all connected clients. *   Scheduling event processing and connection timeouts. *   Handling signals for graceful shutdown.</p>"},{"location":"wiki/Networking/#packethpp","title":"<code>Packet.hpp</code>","text":"<p>This file (<code>core/network/Packet.hpp</code>) defines the structure of all network packets used in the R-Type protocol. It includes:</p> <ul> <li><code>PacketType</code> Enum: An enumeration of all possible packet types (e.g., <code>Message</code>, <code>Move</code>, <code>NewPlayer</code>, <code>EnemySpawn</code>, <code>PlayerShoot</code>). Each type is assigned a unique <code>uint8_t</code> value.</li> <li><code>PacketHeader</code> Struct: A common header for all packets, containing <code>PacketType type</code> and <code>uint32_t size</code> (total size of the packet including header).</li> <li>Specific Packet Structs: Various <code>struct</code> definitions for different packet types (e.g., <code>MovePacket</code>, <code>NewPlayerPacket</code>, <code>PlayerInfoPacket</code>, <code>EnemySpawnPacket</code>, <code>ProjectileSpawnPacket</code>). These structs are <code>alignas(4)</code> to ensure consistent binary layout.</li> <li>Enums for Game Elements: <code>EnemyType</code> and <code>ProjectileType</code> enums are also defined here to categorize different game elements.</li> </ul>"},{"location":"wiki/Networking/#r-type-network-protocol-rtnp","title":"R-Type Network Protocol (RTNP)","text":"<p>The detailed specification of the R-Type Network Protocol (RTNP) can be found in <code>docs/server_protocol.md</code>. Key aspects include:</p> <ul> <li>UDP-based: All communication occurs over UDP datagrams.</li> <li>Single Packet per Datagram: Each UDP datagram contains exactly one packet.</li> <li>Packet Structure: All packets begin with a <code>PacketHeader</code> followed by a type-specific payload.</li> <li>Unreliable Nature: Due to UDP's unreliability, clients and servers implement their own sequencing and re-synchronization mechanisms using <code>sequence_number</code> fields in various packet types.</li> <li>Message Types: A comprehensive list of client-to-server and server-to-client messages, detailing their purpose and payload fields.</li> <li>Data Types: Specifies the data types used (e.g., <code>uint8_t</code>, <code>uint32_t</code>, <code>float</code>, <code>char[]</code> for strings) and their endianness/alignment.</li> <li>Message Semantics: Guidelines for packet validation, sequence number usage, and heartbeat mechanisms.</li> <li>No Authentication/Encryption: The current protocol does not include authentication or encryption and is intended for controlled environments. Future work may address these security considerations.</li> </ul>"},{"location":"wiki/Networking/#communication-flow-example","title":"Communication Flow Example","text":"<ol> <li>Client Connection: A client sends a <code>PlayerInfo</code> packet to the server to identify itself.</li> <li>Server Acknowledgment: The server responds with a <code>NewPlayer</code> packet to the client and broadcasts it to other connected clients.</li> <li>Gameplay Loop: Both client and server continuously exchange movement, projectile, and event packets to synchronize game state.</li> <li>Keep-Alive: <code>Heartbeat</code> packets are exchanged periodically to maintain the connection state and prevent timeouts.</li> </ol>"},{"location":"wiki/ProjectStructure/","title":"Project Structure","text":"<p>This page details the overall directory and file structure of the R-Type project, explaining the purpose of each major component.</p> <pre><code>R-Type/\n\u251c\u2500\u2500\u2500.github/                  # GitHub Actions workflows for CI/CD\n\u251c\u2500\u2500\u2500.venv/                    # Python virtual environment (likely for Conan or other tooling)\n\u251c\u2500\u2500\u2500.venv-docker/             # Docker-related Python virtual environment\n\u251c\u2500\u2500\u2500client/                   # Client-side application source code and assets\n\u2502   \u251c\u2500\u2500\u2500AssetManager.cpp/.hpp # Manages game assets (sprites, textures)\n\u2502   \u251c\u2500\u2500\u2500Client.cpp/.hpp       # Main client application logic\n\u2502   \u251c\u2500\u2500\u2500client.properties     # Configuration file for the client\n\u2502   \u251c\u2500\u2500\u2500CMakeLists.txt        # CMake build script for the client\n\u2502   \u251c\u2500\u2500\u2500EmbedAssets.cpp       # Utility to embed assets into the executable\n\u2502   \u251c\u2500\u2500\u2500EmbeddedAssets.cpp/.hpp # Embedded asset data\n\u2502   \u251c\u2500\u2500\u2500main.cpp              # Client entry point\n\u2502   \u251c\u2500\u2500\u2500ProjectileSpriteConfig.hpp # Configuration for projectile sprites\n\u2502   \u251c\u2500\u2500\u2500RenderManager.cpp/.hpp # Handles all rendering operations\n\u2502   \u2514\u2500\u2500\u2500packets/              # Client-side packet handling\n\u2502       \u251c\u2500\u2500\u2500APacket.hpp       # Abstract base class for packets\n\u2502       \u251c\u2500\u2500\u2500IPacket.hpp       # Interface for packets\n\u2502       \u251c\u2500\u2500\u2500PacketFactory.cpp/.hpp # Factory for creating packets\n\u2502       \u251c\u2500\u2500\u2500PacketHandler.cpp/.hpp # Handles incoming and outgoing packets\n\u2502   \u2514\u2500\u2500\u2500resources/            # Game assets (images, spritesheets)\n\u251c\u2500\u2500\u2500core/                     # Core shared utilities and networking components\n\u2502   \u251c\u2500\u2500\u2500Parser.cpp/.hpp       # Utility for parsing (e.g., configuration files)\n\u2502   \u251c\u2500\u2500\u2500errors/               # Custom error classes\n\u2502   \u2502   \u2514\u2500\u2500\u2500ParamsError.hpp   # Error for invalid parameters\n\u2502   \u2514\u2500\u2500\u2500network/              # Core networking components\n\u2502       \u251c\u2500\u2500\u2500BaseNetworkManager.hpp # Base class for network managers\n\u2502       \u251c\u2500\u2500\u2500ClientNetworkManager.cpp/.hpp # Client-specific network management\n\u2502       \u251c\u2500\u2500\u2500Packet.hpp        # Defines the structure of network packets\n\u2502       \u251c\u2500\u2500\u2500PacketBuilder.hpp # Utility for building packets\n\u2502       \u251c\u2500\u2500\u2500PacketSender.hpp  # Handles sending packets\n\u2502       \u251c\u2500\u2500\u2500ServerNetworkManager.cpp/.hpp # Server-specific network management\n\u2502   \u2514\u2500\u2500\u2500utils/                # General utility functions/macros\n\u2502       \u2514\u2500\u2500\u2500Macro.hpp         # Common macros\n\u251c\u2500\u2500\u2500docs/                     # Project documentation\n\u2502   \u251c\u2500\u2500\u2500server_how_to.md      # Guide for setting up the server\n\u2502   \u251c\u2500\u2500\u2500server_protocol.md    # Server communication protocol specification\n\u2502   \u2514\u2500\u2500\u2500wiki/                 # GitHub Wiki markdown files (this directory)\n\u251c\u2500\u2500\u2500game_engine/              # Core Entity-Component-System (ECS) implementation\n\u2502   \u2514\u2500\u2500\u2500ecs/                  # ECS framework\n\u2502       \u251c\u2500\u2500\u2500Component.hpp     # Base class for components\n\u2502       \u251c\u2500\u2500\u2500ComponentManager.hpp # Manages components\n\u2502       \u251c\u2500\u2500\u2500ECSManager.hpp    # Main ECS manager\n\u2502       \u251c\u2500\u2500\u2500EntityManager.cpp/.hpp # Manages entities\n\u2502       \u251c\u2500\u2500\u2500System.hpp        # Base class for systems\n\u2502       \u251c\u2500\u2500\u2500SystemManager.hpp # Manages systems\n\u2502       \u251c\u2500\u2500\u2500components/       # Specific component implementations\n\u2502       \u2502   \u251c\u2500\u2500\u2500ColliderComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500EnemyComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500HealthComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500PlayerComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500PositionComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500ProjectileComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500RenderComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500ScaleComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500ScoreComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500ShootComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500SpeedComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500SpriteAnimationComponent.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500SpriteComponent.hpp\n\u2502       \u2502   \u2514\u2500\u2500\u2500VelocityComponent.hpp\n\u2502       \u251c\u2500\u2500\u2500systems/          # Specific system implementations\n\u2502       \u2502   \u251c\u2500\u2500\u2500BackgroundSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500BoundarySystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500CollisionSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500EnemySystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500InputSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500MovementSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500ProjectileSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500RenderSystem.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500SpriteAnimationSystem.cpp/.hpp\n\u2502       \u2514\u2500\u2500\u2500tags/             # Tag components (components without data)\n\u2502           \u251c\u2500\u2500\u2500BackgroundTagComponent.hpp\n\u2502           \u251c\u2500\u2500\u2500LocalPlayerTagComponent.hpp\n\u2502           \u2514\u2500\u2500\u2500PlayerTagComponent.hpp\n\u251c\u2500\u2500\u2500server/                   # Server-side application source code\n\u2502   \u251c\u2500\u2500\u2500CMakeLists.txt        # CMake build script for the server\n\u2502   \u251c\u2500\u2500\u2500server.properties     # Configuration file for the server\n\u2502   \u2514\u2500\u2500\u2500src/                  # Server source files\n\u2502       \u251c\u2500\u2500\u2500Broadcast.hpp     # Utility for broadcasting messages\n\u2502       \u251c\u2500\u2500\u2500Help.cpp/.hpp     # Help command implementation\n\u2502       \u251c\u2500\u2500\u2500main.cpp          # Server entry point\n\u2502       \u251c\u2500\u2500\u2500Server.cpp/.hpp   # Main server application logic\n\u2502       \u251c\u2500\u2500\u2500enemy/            # Enemy-related logic\n\u2502       \u2502   \u251c\u2500\u2500\u2500Enemy.cpp/.hpp\n\u2502       \u251c\u2500\u2500\u2500game/             # Game logic and state management\n\u2502       \u2502   \u251c\u2500\u2500\u2500Game.cpp/.hpp\n\u2502       \u251c\u2500\u2500\u2500packets/          # Server-side packet handling (similar to client)\n\u2502       \u2502   \u251c\u2500\u2500\u2500APacket.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500IPacket.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500PacketFactory.cpp/.hpp\n\u2502       \u2502   \u251c\u2500\u2500\u2500PacketHandler.cpp/.hpp\n\u2502       \u251c\u2500\u2500\u2500player/           # Player-related logic\n\u2502       \u2502   \u251c\u2500\u2500\u2500Player.cpp/.hpp\n\u2502       \u251c\u2500\u2500\u2500projectile/       # Projectile-related logic\n\u2502       \u2502   \u251c\u2500\u2500\u2500Projectile.cpp/.hpp\n\u2502       \u2514\u2500\u2500\u2500queue/            # Event queue for server\n\u2502           \u251c\u2500\u2500\u2500Events.hpp\n\u2502           \u2514\u2500\u2500\u2500Queue.hpp\n\u2502   \u2514\u2500\u2500\u2500tests/                # Server unit tests\n\u251c\u2500\u2500\u2500.gitignore                # Git ignore rules\n\u251c\u2500\u2500\u2500build.sh                  # Build script\n\u251c\u2500\u2500\u2500CMakeLists.txt            # Main CMake project file\n\u251c\u2500\u2500\u2500conanfile_server.txt      # Conan dependencies for the server\n\u251c\u2500\u2500\u2500conanfile.txt             # Main Conan dependencies\n\u251c\u2500\u2500\u2500README_BUILD.md           # Build instructions\n\u251c\u2500\u2500\u2500README.md                 # Main project README\n\u2514\u2500\u2500\u2500TECHNICAL_COMPARATIVE_STUDY.md # Technical study document\n</code></pre>"},{"location":"wiki/ProjectStructure/#main-directories-explained","title":"Main Directories Explained","text":"<ul> <li><code>.github/</code>: Contains GitHub Actions workflows for continuous integration and deployment.</li> <li><code>client/</code>: Houses all the code and resources specific to the R-Type client application. This includes rendering logic, asset management, client-side networking, and the main client application entry point.</li> <li><code>core/</code>: This directory contains shared code that is utilized by both the client and the server. It includes common utilities, error handling, and the foundational networking components.</li> <li><code>docs/</code>: Stores project documentation, including detailed server setup guides, network protocol specifications, and the GitHub Wiki markdown files.</li> <li><code>game_engine/</code>: This is where the core Entity-Component-System (ECS) framework is implemented. It defines the base classes and managers for entities, components, and systems, along with specific implementations for various game mechanics.</li> <li><code>server/</code>: Contains all the code and logic for the R-Type game server. This includes game state management, server-side networking, and specific game entities like enemies, players, and projectiles.</li> <li><code>.venv/</code> &amp; <code>.venv-docker/</code>: These directories typically contain Python virtual environments, likely used for managing development tools, Conan, or Docker-related scripting.</li> <li>Root Files:<ul> <li><code>build.sh</code>: A shell script to automate the build process.</li> <li><code>CMakeLists.txt</code>: The primary CMake configuration file for the entire project.</li> <li><code>conanfile.txt</code> &amp; <code>conanfile_server.txt</code>: Conan recipe files specifying project dependencies.</li> <li><code>README.md</code>, <code>README_BUILD.md</code>, <code>TECHNICAL_COMPARATIVE_STUDY.md</code>: Project documentation and build instructions.</li> </ul> </li> </ul>"}]}